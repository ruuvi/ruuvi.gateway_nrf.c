
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>ruuvi_driver_sensor.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">#ifndef RUUVI_DRIVER_SENSOR_H</a>
<a name="ln2">#define RUUVI_DRIVER_SENSOR_H</a>
<a name="ln3">/**</a>
<a name="ln4"> * @defgroup Sensor Common sensor interface</a>
<a name="ln5"> * @brief Functions for setting up and using sensors</a>
<a name="ln6"> *</a>
<a name="ln7"> *</a>
<a name="ln8"> */</a>
<a name="ln9">/*@{*/</a>
<a name="ln10">/**</a>
<a name="ln11"> * @file ruuvi_driver_sensor.h</a>
<a name="ln12"> * @author Otso Jousimaa &lt;otso@ojousima.net&gt;</a>
<a name="ln13"> * @date 2020-06-01</a>
<a name="ln14"> * @copyright Ruuvi Innovations Ltd, license BSD-3-Clause</a>
<a name="ln15"> * @brief Ruuvi sensor interface &lt;b&gt;Lifecycle: Beta&lt;/b&gt;</a>
<a name="ln16"> *</a>
<a name="ln17"> *</a>
<a name="ln18"> *</a>
<a name="ln19"> * Common interface to all Ruuvi Sensors</a>
<a name="ln20"> * Every sensor must implement these functions:</a>
<a name="ln21"> * - init</a>
<a name="ln22"> * - uninit</a>
<a name="ln23"> * - samplerate_set</a>
<a name="ln24"> * - samplerate_get</a>
<a name="ln25"> * - dsp_set</a>
<a name="ln26"> * - dsp_get</a>
<a name="ln27"> * - scale_set</a>
<a name="ln28"> * - scale_set</a>
<a name="ln29"> * - resolution_set</a>
<a name="ln30"> * - resolution_get</a>
<a name="ln31"> * - mode_set</a>
<a name="ln32"> * - mode_get</a>
<a name="ln33"> * - data_get</a>
<a name="ln34"> *</a>
<a name="ln35"> * If function does not make sense for the sensor, it will return error code.</a>
<a name="ln36"> *</a>
<a name="ln37"> * Return name: Return a pointer to a constant 8-byte long string which represensts sensor, e.g. LIS2DH12\0 or BME280\0\0</a>
<a name="ln38"> *</a>
<a name="ln39"> * INIT, UNINT: Init will prepare sensor for use, reset the sensor, run self-test and place it in low-power mode. Additionally function pointers will be set up by init.</a>
<a name="ln40"> *              Uninit will release any resources used by sensor</a>
<a name="ln41"> *</a>
<a name="ln42"> * Samplerate: Applicable on continuous mode, how often sensor takes samples. Hz</a>
<a name="ln43"> *</a>
<a name="ln44"> * DSP: DSP function and parameter, i.e. &quot;OVERSAMPLING, 16&quot;. Return error if the device does not support it.</a>
<a name="ln45"> *</a>
<a name="ln46"> * scale: Maximum scale in a meaningful physical unit, such as celcius or pascal.</a>
<a name="ln47"> *</a>
<a name="ln48"> * resolution: Resolution in bits.</a>
<a name="ln49"> *</a>
<a name="ln50"> * mode: Sleep, single, continuous.</a>
<a name="ln51"> *  - Sleep mode should enter lowest-power state available</a>
<a name="ln52"> *  - Single will return once new data is available with data_get call</a>
<a name="ln53"> *  - Continuous: Sensor will sample at given rate. Returns immediately, data will be available after first sample</a>
<a name="ln54"> *</a>
<a name="ln55"> * data get: return latest sample from sensor</a>
<a name="ln56"> */</a>
<a name="ln57"> </a>
<a name="ln58">#include &quot;ruuvi_driver_error.h&quot;</a>
<a name="ln59">#include &lt;stdbool.h&gt;</a>
<a name="ln60">#include &lt;stddef.h&gt;</a>
<a name="ln61">#include &lt;stdint.h&gt;</a>
<a name="ln62"> </a>
<a name="ln63">#define RD_SENSOR_INVALID_VALUE    RD_FLOAT_INVALID  //!&lt; Signal this sensor value is erroneous</a>
<a name="ln64">#define RD_SENSOR_INVALID_TIMSTAMP RD_UINT64_INVALID //!&lt; Signal this timestamp value is erroneous</a>
<a name="ln65"> </a>
<a name="ln66">// Constants for sensor configuration and status</a>
<a name="ln67">#define RD_SENSOR_CFG_DEFAULT         (0U)      //!&lt; Default value, always valid for the sensor.</a>
<a name="ln68">#define RD_SENSOR_CFG_CUSTOM_1        (0xC9U)   //!&lt; Configuration range is 0...200, i.e. 0 ... 0xC8. Use C9 ... CF as sensor-specific values.</a>
<a name="ln69">#define RD_SENSOR_CFG_CUSTOM_2        (0xCAU)   //!&lt; Configuration range is 0...200, i.e. 0 ... 0xC8. Use C9 ... CF as sensor-specific values.</a>
<a name="ln70">#define RD_SENSOR_CFG_CUSTOM_3        (0xCBU)   //!&lt; Configuration range is 0...200, i.e. 0 ... 0xC8. Use C9 ... CF as sensor-specific values.</a>
<a name="ln71">#define RD_SENSOR_CFG_CUSTOM_4        (0xCCU)   //!&lt; Configuration range is 0...200, i.e. 0 ... 0xC8. Use C9 ... CF as sensor-specific values.</a>
<a name="ln72">#define RD_SENSOR_CFG_CUSTOM_5        (0xCDU)   //!&lt; Configuration range is 0...200, i.e. 0 ... 0xC8. Use C9 ... CF as sensor-specific values.</a>
<a name="ln73">#define RD_SENSOR_CFG_CUSTOM_6        (0xCEU)   //!&lt; Configuration range is 0...200, i.e. 0 ... 0xC8. Use C9 ... CF as sensor-specific values.</a>
<a name="ln74">#define RD_SENSOR_ERR_INVALID         (0xE0U)   //!&lt; Error code, given parameter is invalid</a>
<a name="ln75">#define RD_SENSOR_ERR_NOT_IMPLEMENTED (0xE1U)   //!&lt; Error code, given parameter is not implemented (todo)</a>
<a name="ln76">#define RD_SENSOR_ERR_NOT_SUPPORTED   (0xE2U)   //!&lt; Error code, given parameter is not supported by sensor</a>
<a name="ln77">#define RD_SENSOR_CFG_MIN             (0xF0U)   //!&lt; Configure smallest supported and implemented value</a>
<a name="ln78">#define RD_SENSOR_CFG_MAX             (0xF1U)   //!&lt; Configure largest supported and implemented value</a>
<a name="ln79">#define RD_SENSOR_CFG_SLEEP           (0xF2U)   //!&lt; Sensor should go to sleep immediately</a>
<a name="ln80">#define RD_SENSOR_CFG_SINGLE          (0xF3U)   //!&lt; Sensor should go to sleep after single measurement</a>
<a name="ln81">#define RD_SENSOR_CFG_CONTINUOUS      (0xF4U)   //!&lt; Sensor will keep sampling at defined sample rate</a>
<a name="ln82">#define RD_SENSOR_CFG_NO_CHANGE       (0xFFU)   //!&lt; Do not change configured value</a>
<a name="ln83"> </a>
<a name="ln84">// DSP functions, complemented by DSP parameter</a>
<a name="ln85">#define RD_SENSOR_DSP_LAST            (0U)    //!&lt; Return last value from sensor. Parameter: No effect. Use default</a>
<a name="ln86">#define RD_SENSOR_DSP_LOW_PASS        (1U&lt;&lt;1U) //!&lt; Low pass sensor values Parameter: coefficient</a>
<a name="ln87">#define RD_SENSOR_DSP_HIGH_PASS       (1U&lt;&lt;2U) //!&lt; High pass sensor values Parameter: coefficient</a>
<a name="ln88">#define RD_SENSOR_DSP_OS              (1U&lt;&lt;3U) //!&lt; Oversample sensor values. Parameter: Number of samples</a>
<a name="ln89"> </a>
<a name="ln90">/** @brief convert Ruuvi GPIO into uint8_t */</a>
<a name="ln91">#define RD_GPIO_TO_HANDLE(handle) ((((handle) &gt;&gt; 3U) &amp; 0xE0U) + ((handle) &amp; 0x1FU))</a>
<a name="ln92">/** @brief convert uint8_t into Ruuvi GPIO */</a>
<a name="ln93">#define RD_HANDLE_TO_GPIO(handle) ((((handle) &amp; 0xE0U) &lt;&lt; 3U) + ((handle) &amp; 0x1FU))</a>
<a name="ln94"> </a>
<a name="ln95">/**</a>
<a name="ln96"> * @brief All sensors must implement configuration functions which accept this struct.</a>
<a name="ln97"> */</a>
<a name="ln98">typedef struct __attribute__ ( (packed, aligned (4)))</a>
<a name="ln99">{</a>
<a name="ln100">    uint8_t samplerate;     //!&lt; Samplerate, in Hz</a>
<a name="ln101">    uint8_t resolution;     //!&lt; Resolution, in bits</a>
<a name="ln102">    uint8_t scale;          //!&lt; Scale, in relevant Si-unit</a>
<a name="ln103">    uint8_t dsp_function;   //!&lt; DSP function, one of @c RD_SENSOR_DSP_*</a>
<a name="ln104">    uint8_t dsp_parameter;  //!&lt; Parameter to DSP functions</a>
<a name="ln105">    uint8_t mode;           //!&lt; Mode, RD_SENSOR_SLEEP, _SINGLE, _CONTINOUS</a>
<a name="ln106">    uint8_t reserved0;      //!&lt; Reserved for future use</a>
<a name="ln107">    uint8_t reserved1;      //!&lt; Reserved for future use</a>
<a name="ln108">}</a>
<a name="ln109">rd_sensor_configuration_t;</a>
<a name="ln110"> </a>
<a name="ln111">/**</a>
<a name="ln112"> * @brief Type of bus sensor uses.</a>
<a name="ln113"> */</a>
<a name="ln114">typedef enum</a>
<a name="ln115">{</a>
<a name="ln116">    RD_BUS_NONE = 0U, //!&lt; No bus, internal to IC</a>
<a name="ln117">    RD_BUS_SPI  = 1U, //!&lt; SPI bus</a>
<a name="ln118">    RD_BUS_I2C  = 2U, //!&lt; I2C bus</a>
<a name="ln119">    RD_BUS_UART = 3U, //!&lt; UART bus</a>
<a name="ln120">    RD_BUS_PDM  = 4U, //!&lt; PDM bus</a>
<a name="ln121">    RD_BUS_FAIL = 5U  //!&lt; Test behaviour on invalid bus with this value.</a>
<a name="ln122">} rd_bus_t;</a>
<a name="ln123"> </a>
<a name="ln124">/**</a>
<a name="ln125"> * @brief Bitfield to describe related sensor data</a>
<a name="ln126"> */</a>
<a name="ln127">typedef struct</a>
<a name="ln128">{</a>
<a name="ln129">    unsigned int acceleration_x_g : 1; //!&lt; Acceleration along X-axis, gravities.</a>
<a name="ln130">    unsigned int acceleration_y_g : 1; //!&lt; Acceleration along Y-axis, gravities.</a>
<a name="ln131">    unsigned int acceleration_z_g : 1; //!&lt; Acceleration along Z-axis, gravities.</a>
<a name="ln132">    unsigned int co2_ppm : 1;          //!&lt; CO2, Parts per million.</a>
<a name="ln133">    unsigned int gyro_x_dps : 1;       //!&lt; Rotation along X-axis, degrees per second.</a>
<a name="ln134">    unsigned int gyro_y_dps : 1;       //!&lt; Rotation along Y-axis, degrees per second.</a>
<a name="ln135">    unsigned int gyro_z_dps : 1;       //!&lt; Rotation along Z-axis, degrees per second.</a>
<a name="ln136">    unsigned int humidity_rh : 1;      //!&lt; Relative humidity, %.</a>
<a name="ln137">    /** @brief Light level, dimensionless. Comparable only between identical devices. */</a>
<a name="ln138">    unsigned int luminosity  : 1;</a>
<a name="ln139">    unsigned int magnetometer_x_g : 1; //!&lt; Magnetic flux along X-axis, Gauss.</a>
<a name="ln140">    unsigned int magnetometer_y_g : 1; //!&lt; Magnetic flux along Y-axis, Gauss.</a>
<a name="ln141">    unsigned int magnetometer_z_g : 1; //!&lt; Magnetic flux along Z-axis, Gauss.</a>
<a name="ln142">    unsigned int pm_1_ugm3 : 1;        //!&lt; Ultra-fine particulate matter, microgram per m^3.</a>
<a name="ln143">    unsigned int pm_2_ugm3 : 1;        //!&lt; Fine particulate matter, microgram per m^3.</a>
<a name="ln144">    unsigned int pm_4_ugm3 : 1;        //!&lt; Medium particulate matter, microgram per m^3.</a>
<a name="ln145">    unsigned int pm_10_ugm3 : 1;       //!&lt; Coarse particulate matter, microgram per m^3.</a>
<a name="ln146">    unsigned int pressure_pa : 1;      //!&lt; Pressure, pascals</a>
<a name="ln147">    unsigned int spl_dbz : 1;          //!&lt; Unweighted sound pressure level.</a>
<a name="ln148">    unsigned int temperature_c : 1;    //!&lt; Temperature, celcius</a>
<a name="ln149">    unsigned int voc_ppm : 1;          //!&lt; Volatile organic compounds, parts per million.</a>
<a name="ln150">    unsigned int voltage_v : 1;        //!&lt; Voltage, volts.</a>
<a name="ln151">    unsigned int voltage_ratio : 1;    //!&lt; Voltage, ratio to maximum</a>
<a name="ln152">} rd_sensor_data_bitfield_t;</a>
<a name="ln153"> </a>
<a name="ln154">/**</a>
<a name="ln155"> * @brief Union to access sensor data.</a>
<a name="ln156"> *</a>
<a name="ln157"> * MISRA deviation: Use of union.</a>
<a name="ln158"> * Union is used here for fast operations on sensor data through field bitfield</a>
<a name="ln159"> * and to give a meaningful value to each bit through datas.</a>
<a name="ln160"> *</a>
<a name="ln161"> * C99 and onwards allow type punning, but this is not portable to C++.</a>
<a name="ln162"> * Run the integration tests on your platform.</a>
<a name="ln163"> *</a>
<a name="ln164"> */</a>
<a name="ln165">typedef union // -V2514</a>
<a name="ln166">{</a>
<a name="ln167">    uint32_t bitfield; //!&lt; Bitfield used to access sensor data.</a>
<a name="ln168">    rd_sensor_data_bitfield_t datas; //!&lt; Structured data field.</a>
<a name="ln169">} rd_sensor_data_fields_t;</a>
<a name="ln170"> </a>
<a name="ln171">/**</a>
<a name="ln172"> * @brief Generic sensor data struct.</a>
<a name="ln173"> *</a>
<a name="ln174"> * The data sensor struct contains a timestamp relative to sensor boot,</a>
<a name="ln175"> * a list of fields contained within the sensor data and a pointer to array</a>
<a name="ln176"> * of floats which contain the actual data.</a>
<a name="ln177"> */</a>
<a name="ln178">typedef struct rd_sensor_data_t</a>
<a name="ln179">{</a>
<a name="ln180">    uint64_t timestamp_ms;      //!&lt; Timestamp of the event, @ref rd_sensor_timestamp_get.</a>
<a name="ln181">    rd_sensor_data_fields_t</a>
<a name="ln182">    fields; //!&lt; Description of datafields which may be contained in this sample.</a>
<a name="ln183">    rd_sensor_data_fields_t valid;  //!&lt; Listing of valid data in this sample.</a>
<a name="ln184">    /** @brief Data of sensor. Must contain as many elements as fields has bits set. */</a>
<a name="ln185">    float * data;</a>
<a name="ln186">} rd_sensor_data_t;</a>
<a name="ln187"> </a>
<a name="ln188">/** @brief Forward declare type definition of sensor structure */</a>
<a name="ln189">typedef struct rd_sensor_t rd_sensor_t;</a>
<a name="ln190"> </a>
<a name="ln191">/**</a>
<a name="ln192"> * @brief Initialize and uninitialize sensor.</a>
<a name="ln193"> * Init and uninit will setup sensor with function pointers.</a>
<a name="ln194"> * The sensor wil be initialized to lowest power state possible.</a>
<a name="ln195"> *</a>
<a name="ln196"> * @param[in,out] p_sensor pointer to sensor structure</a>
<a name="ln197"> * @param[in] bus bus to use, i.r. I2C or SPI</a>
<a name="ln198"> * @param[in] handle for the sensor, for example I2C address or SPI chip select pin</a>
<a name="ln199"> * @return @c RD_SUCCESS on success</a>
<a name="ln200"> * @return @c RD_ERROR_NULL if p_sensor is NULL</a>
<a name="ln201"> * @return @c RD_ERROR_NOT_FOUND if there is no response from sensor or if ID of</a>
<a name="ln202"> *            a sensor read over bus does not match expected value</a>
<a name="ln203"> * @return @c RD_ERROR_SELFTEST if sensor is found but it does not pass selftest</a>
<a name="ln204"> * @return @c RD_ERROR_INVALID_STATE if trying to initialize sensor which</a>
<a name="ln205"> *            already has been initialized.</a>
<a name="ln206"> **/</a>
<a name="ln207">typedef rd_status_t (*rd_sensor_init_fp) (rd_sensor_t * const</a>
<a name="ln208">        p_sensor, const rd_bus_t bus, const uint8_t handle);</a>
<a name="ln209"> </a>
<a name="ln210">/**</a>
<a name="ln211"> *  @brief Setup a parameter of a sensor.</a>
<a name="ln212"> *  The function will modify the pointed data to the actual value which was written</a>
<a name="ln213"> *</a>
<a name="ln214"> *  @param[in,out] parameter value to write to sensor configuration. Actual value written to sensor as output</a>
<a name="ln215"> *  @return RD_SUCCESS on success</a>
<a name="ln216"> *  @return RD_ERROR_NULL if parameter is NULL</a>
<a name="ln217"> *  @return RD_ERROR_NOT_SUPPORTED if sensor cannot support given parameter</a>
<a name="ln218"> *  @return RD_ERROR_NOT_IMPLEMENTED if the sensor could support parameter, but it's not implemented in fw.</a>
<a name="ln219"> **/</a>
<a name="ln220">typedef rd_status_t (*rd_sensor_setup_fp) (uint8_t * parameter);</a>
<a name="ln221"> </a>
<a name="ln222">/**</a>
<a name="ln223"> * @brief Configure sensor digital signal processing.</a>
<a name="ln224"> * Takes DSP function and a DSP parameter as input, configured value or error code as output.</a>
<a name="ln225"> * Modifies input parameters to actual values written on the sensor.</a>
<a name="ln226"> * DSP functions are run on the sensor HW, not in the platform FW.</a>
<a name="ln227"> *</a>
<a name="ln228"> * @param[in,out] dsp_function. DSP function to run on sensor. Can be a combination of several functions.</a>
<a name="ln229"> * @param[in,out] dsp_parameter. Parameter to DSP function(s)</a>
<a name="ln230"> * @return RD_SUCCESS on success</a>
<a name="ln231"> * @return RD_ERROR_NULL if either parameter is NULL</a>
<a name="ln232"> * @return RD_ERROR_NOT_SUPPORTED if sensor doesn't support given DSP</a>
<a name="ln233"> * @return RD_ERROR_NOT_IMPLEMENTED if sensor supports given DSP, but</a>
<a name="ln234"> *         driver does not implement it</a>
<a name="ln235"> * @return RD_ERROR_INVALID_PARAM if parameter is invalid for any reason.</a>
<a name="ln236"> **/</a>
<a name="ln237">typedef rd_status_t (*rd_sensor_dsp_fp) (uint8_t * dsp_function,</a>
<a name="ln238">        uint8_t * dsp_parameter);</a>
<a name="ln239"> </a>
<a name="ln240">/**</a>
<a name="ln241"> * @brief Read latest data from sensor registers</a>
<a name="ln242"> * Return latest data from sensor. Does not take a new sample, calling this function twice</a>
<a name="ln243"> * in a row returns same data. Configure sensor in a single-shot mode to take a new sample</a>
<a name="ln244"> * or leave sensor in a continuous mode to get updated data.</a>
<a name="ln245"> *</a>
<a name="ln246"> * @param [out] p_data Pointer to sensor data @ref rd_sensor_data_t .</a>
<a name="ln247"> * @return RD_SUCCESS on success</a>
<a name="ln248"> * @return RD_ERROR_NULL if p_data is @c NULL.</a>
<a name="ln249"> *</a>
<a name="ln250"> * @warning if sensor data is not valid for any reason, data is populated with</a>
<a name="ln251"> *          @c RD_FLOAT_INVALID.</a>
<a name="ln252"> */</a>
<a name="ln253">typedef rd_status_t (*rd_sensor_data_fp) (rd_sensor_data_t * const p_data);</a>
<a name="ln254"> </a>
<a name="ln255">/**</a>
<a name="ln256"> * @brief Convenience function to write/read entire configuration in one call.</a>
<a name="ln257"> * Modifies input parameters to actual values written on the sensor.</a>
<a name="ln258"> *</a>
<a name="ln259"> * @param[in] p_sensor sensor to configure</a>
<a name="ln260"> * @param[in,out] p_configuration Input: desired configuration. Output:</a>
<a name="ln261"> *                configuration written to sensot.</a>
<a name="ln262"> * @retval RD_SUCCESS if sensor was configured successfully.</a>
<a name="ln263"> * @retval RD_ERROR_NULL if one of parameters is NULL</a>
<a name="ln264"> * @return Error code from driver on other error.</a>
<a name="ln265"> **/</a>
<a name="ln266">typedef rd_status_t (*rd_configuration_fp) (</a>
<a name="ln267">    const rd_sensor_t * const p_sensor,</a>
<a name="ln268">    rd_sensor_configuration_t * const p_configuration);</a>
<a name="ln269"> </a>
<a name="ln270">/**</a>
<a name="ln271">* @brief Read First-in-first-out (FIFO) buffer in sensor.</a>
<a name="ln272">* Reads up to num_elements data points from FIFO and populates pointer data with them.</a>
<a name="ln273">*</a>
<a name="ln274">* @param[in, out] num_elements Input: number of elements in data.</a>
<a name="ln275">                               Output: Number of elements placed in data.</a>
<a name="ln276">* @param[out] Data array of  with num_elements slots.</a>
<a name="ln277">* @retval RD_SUCCESS on success.</a>
<a name="ln278">* @retval RD_ERROR_NULL if either parameter is NULL.</a>
<a name="ln279">* @retval RD_ERROR_INVALID_STATE if FIFO is not in use.</a>
<a name="ln280">* @retval RD_ERROR_NOT_SUPPORTED if the sensor does not have FIFO.</a>
<a name="ln281">* @return error code from stack on error.</a>
<a name="ln282">*/</a>
<a name="ln283">typedef rd_status_t (*rd_sensor_fifo_read_fp) (size_t * const num_elements,</a>
<a name="ln284">        rd_sensor_data_t * const data);</a>
<a name="ln285"> </a>
<a name="ln286">/**</a>
<a name="ln287">* @brief Enable FIFO or FIFO interrupt full interrupt on sensor.</a>
<a name="ln288">* FIFO interrupt Triggers an interrupt once FIFO is filled.</a>
<a name="ln289">* It is responsibility of application to know the routing of and polarity of GPIO pins and</a>
<a name="ln290">* configure the GPIO to register interrupts.</a>
<a name="ln291">*</a>
<a name="ln292">* @param[in] enable True to enable interrupt, false to disable interrupt</a>
<a name="ln293">* @return RD_SUCCESS on success, error code from stack otherwise.</a>
<a name="ln294">**/</a>
<a name="ln295">typedef rd_status_t (*rd_sensor_fifo_enable_fp) (const bool enable);</a>
<a name="ln296"> </a>
<a name="ln297">/**</a>
<a name="ln298">* @brief Enable level interrupt on sensor.</a>
<a name="ln299">*</a>
<a name="ln300">* Triggers as ACTIVE HIGH interrupt while detected data is above threshold.</a>
<a name="ln301">*</a>
<a name="ln302">* Trigger is symmetric, i.e. threshold is valid for above positive or below negative</a>
<a name="ln303">* of given value.</a>
<a name="ln304">*</a>
<a name="ln305">* On accelerometer data is high-passed to filter out gravity.</a>
<a name="ln306">* Axes are examined individually, compound data won't trigger the interrupt. e.g.</a>
<a name="ln307">* accelerometer showing 0.8 G along X, Y, Z axes won't trigger at threshold of 1 G,</a>
<a name="ln308">* even though the vector sum of axes is larger than 1 G.</a>
<a name="ln309">*</a>
<a name="ln310">* It is responsibility of application to know the GPIO routing and register</a>
<a name="ln311">* GPIO interrupts.</a>
<a name="ln312">*</a>
<a name="ln313">* @param[in] enable  True to enable interrupt, false to disable interrupt</a>
<a name="ln314">* @param[in,out] limit_g: Input: Desired acceleration to trigger the interrupt.</a>
<a name="ln315">*                         Is considered as &quot;at least&quot;, the acceleration is rounded up to</a>
<a name="ln316">*                         next value.</a>
<a name="ln317">*                         Output: written with value that was set to interrupt</a>
<a name="ln318">* @retval RD_SUCCESS on success.</a>
<a name="ln319">* @retval RD_INVALID_STATE if data limit is higher than maximum scale.</a>
<a name="ln320">* @return error code from stack on error.</a>
<a name="ln321">*</a>
<a name="ln322">*/</a>
<a name="ln323">typedef rd_status_t (*rd_sensor_level_interrupt_use_fp) (const bool enable,</a>
<a name="ln324">        float * limit_g);</a>
<a name="ln325"> </a>
<a name="ln326">/**</a>
<a name="ln327"> * @brief Return number of milliseconds since the start of RTC.</a>
<a name="ln328"> *</a>
<a name="ln329"> * @return milliseconds since start of RTC.</a>
<a name="ln330"> * @return RD_UINT64T_INVALID if RTC is not running</a>
<a name="ln331"> */</a>
<a name="ln332">typedef uint64_t (*rd_sensor_timestamp_fp) (void);</a>
<a name="ln333"> </a>
<a name="ln334">/**</a>
<a name="ln335"> * @brief Interface to sensor.</a>
<a name="ln336"> * Some sensors can implement additional functions.</a>
<a name="ln337"> * The additional functions are defined in the interface of the sensor.</a>
<a name="ln338"> */</a>
<a name="ln339">typedef struct rd_sensor_t</a>
<a name="ln340">{</a>
<a name="ln341">    /** @brief sensor human-readable name. Should be at most 8 bytes long. */</a>
<a name="ln342">    const char * name;</a>
<a name="ln343">    /** @brief Description of data fields the sensor is able to provide. */</a>
<a name="ln344">    rd_sensor_data_fields_t provides;</a>
<a name="ln345">    /** @brief @ref rd_sensor_init_fp */</a>
<a name="ln346">    rd_sensor_init_fp   init;</a>
<a name="ln347">    /** @brief @ref rd_sensor_init_fp */</a>
<a name="ln348">    rd_sensor_init_fp   uninit;</a>
<a name="ln349">    /** @brief @ref rd_sensor_setup_fp */</a>
<a name="ln350">    rd_sensor_setup_fp samplerate_set;</a>
<a name="ln351">    /** @brief @ref rd_sensor_setup_fp */</a>
<a name="ln352">    rd_sensor_setup_fp samplerate_get;</a>
<a name="ln353">    /** @brief @ref rd_sensor_setup_fp */</a>
<a name="ln354">    rd_sensor_setup_fp resolution_set;</a>
<a name="ln355">    /** @brief @ref rd_sensor_setup_fp */</a>
<a name="ln356">    rd_sensor_setup_fp resolution_get;</a>
<a name="ln357">    /** @brief @ref rd_sensor_setup_fp */</a>
<a name="ln358">    rd_sensor_setup_fp scale_set;</a>
<a name="ln359">    /** @brief @ref rd_sensor_setup_fp */</a>
<a name="ln360">    rd_sensor_setup_fp scale_get;</a>
<a name="ln361">    /** @brief @ref rd_sensor_setup_fp */</a>
<a name="ln362">    rd_sensor_setup_fp mode_set;</a>
<a name="ln363">    /** @brief @ref rd_sensor_setup_fp */</a>
<a name="ln364">    rd_sensor_setup_fp mode_get;</a>
<a name="ln365">    /** @brief @ref rd_sensor_dsp_fp */</a>
<a name="ln366">    rd_sensor_dsp_fp   dsp_set;</a>
<a name="ln367">    /** @brief @ref rd_sensor_dsp_fp */</a>
<a name="ln368">    rd_sensor_dsp_fp   dsp_get;</a>
<a name="ln369">    /** @brief @ref rd_configuration_fp */</a>
<a name="ln370">    rd_configuration_fp configuration_set;</a>
<a name="ln371">    /** @brief @ref rd_configuration_fp */</a>
<a name="ln372">    rd_configuration_fp configuration_get;</a>
<a name="ln373">    /** @brief @ref rd_sensor_data_fp */</a>
<a name="ln374">    rd_sensor_data_fp   data_get;</a>
<a name="ln375">    /** @brief @速ef rd_sensor_fifo_enable_fp */</a>
<a name="ln376">    rd_sensor_fifo_enable_fp fifo_enable;</a>
<a name="ln377">    /** @brief @速ef rd_sensor_level_interrupt_use_fp */</a>
<a name="ln378">    rd_sensor_fifo_enable_fp fifo_interrupt_enable;</a>
<a name="ln379">    /** @brief @速ef rd_sensor_level_interrupt_use_fp */</a>
<a name="ln380">    rd_sensor_fifo_read_fp   fifo_read;</a>
<a name="ln381">    /** @brief @速ef rd_sensor_level_interrupt_use_fp */</a>
<a name="ln382">    rd_sensor_level_interrupt_use_fp level_interrupt_set;</a>
<a name="ln383">} rd_sensor_t;</a>
<a name="ln384"> </a>
<a name="ln385">/**</a>
<a name="ln386"> * @brief Implementation of ref rd_configuration_fp</a>
<a name="ln387"> */</a>
<a name="ln388">rd_status_t rd_sensor_configuration_set (const rd_sensor_t *</a>
<a name="ln389">        sensor, rd_sensor_configuration_t * config);</a>
<a name="ln390"> </a>
<a name="ln391">/**</a>
<a name="ln392"> * @brief Implementation of ref rd_configuration_fp</a>
<a name="ln393"> */</a>
<a name="ln394">rd_status_t rd_sensor_configuration_get (const rd_sensor_t *</a>
<a name="ln395">        sensor, rd_sensor_configuration_t * config);</a>
<a name="ln396"> </a>
<a name="ln397">/**</a>
<a name="ln398"> * @brief Setup timestamping.</a>
<a name="ln399"> * Set to @c NULL to disable timestamps.</a>
<a name="ln400"> *</a>
<a name="ln401"> * @param[in] timestamp_fp Function pointer to @ref rd_sensor_timestamp_fp implementation</a>
<a name="ln402"> * @retval RD_SUCCESS.</a>
<a name="ln403"> */</a>
<a name="ln404">rd_status_t rd_sensor_timestamp_function_set (</a>
<a name="ln405">    const rd_sensor_timestamp_fp  timestamp_fp);</a>
<a name="ln406"> </a>
<a name="ln407">/**</a>
<a name="ln408"> * @brief Calls the timestamp function and returns its value.</a>
<a name="ln409"> * @return milliseconds since the start of RTC.</a>
<a name="ln410"> * @retval RD_UINT64_INVALID if timestamp function is NULL</a>
<a name="ln411"> */</a>
<a name="ln412">uint64_t rd_sensor_timestamp_get (void);</a>
<a name="ln413"> </a>
<a name="ln414">/**</a>
<a name="ln415"> * @brief Initialize sensor struct with non-null pointers which</a>
<a name="ln416"> *        return RD_ERROR_NOT_INITIALIZED.</a>
<a name="ln417"> *</a>
<a name="ln418"> * This function is to ensure that NULL function pointers won't be called.</a>
<a name="ln419"> * If name was NULL before calling this, name will point to &quot;NOTINIT&quot;.</a>
<a name="ln420"> * If name was already set, it won't be changed.</a>
<a name="ln421"> *</a>
<a name="ln422"> * @param[out] p_sensor pointer to sensor struct to initialize.</a>
<a name="ln423"> */</a>
<a name="ln424">void rd_sensor_initialize (rd_sensor_t * const p_sensor);</a>
<a name="ln425"> </a>
<a name="ln426">/**</a>
<a name="ln427"> * @brief Mark sensor as uninitialized by calling the generic initialization.</a>
<a name="ln428"> * Will not clear the name of the sensor.</a>
<a name="ln429"> *</a>
<a name="ln430"> * @param[out] p_sensor pointer to sensor struct to uninitialize.</a>
<a name="ln431"> */</a>
<a name="ln432">void rd_sensor_uninitialize (rd_sensor_t * const p_sensor);</a>
<a name="ln433"> </a>
<a name="ln434">/**</a>
<a name="ln435"> * @brief Check if given sensor structure is already initialized.</a>
<a name="ln436"> *</a>
<a name="ln437"> * @param[in] sensor Sensor interface to check.</a>
<a name="ln438"> * @return true if structure is initialized, false otherwise.</a>
<a name="ln439"> */</a>
<a name="ln440">bool rd_sensor_is_init (const rd_sensor_t * const sensor);</a>
<a name="ln441"> </a>
<a name="ln442">/**</a>
<a name="ln443"> * @brief Populate given target data with data provided by sensor as requested.</a>
<a name="ln444"> *</a>
<a name="ln445"> * This function looks up the appropriate assigments on each data field in given target</a>
<a name="ln446"> * and populates it with provided data if caller requested the field to be populated.</a>
<a name="ln447"> * Populated fields are marked as valid.</a>
<a name="ln448"> *</a>
<a name="ln449"> * Example: Board can have these sensors in this order of priority:</a>
<a name="ln450"> *  - TMP117 (temperature)</a>
<a name="ln451"> *  - SHTC3 (temperature, humidity)</a>
<a name="ln452"> *  - DPS310 (temperature, pressure)</a>
<a name="ln453"> *  - LIS2DH12 (acceleration, temperature)</a>
<a name="ln454"> *</a>
<a name="ln455"> * If a target with fields for temperature, humidity, pressure and acceleration is</a>
<a name="ln456"> * created and populated from data of the sensors end result will be:</a>
<a name="ln457"> *</a>
<a name="ln458"> * -&gt; Temperature, timestamp from TMP117</a>
<a name="ln459"> * -&gt; Humidity from SHTC3</a>
<a name="ln460"> * -&gt; Pressure from DPS310</a>
<a name="ln461"> * -&gt; Acceleration from LIS2DH12</a>
<a name="ln462"> *</a>
<a name="ln463"> * If same firmware is run on a board with only LIS2DH12 populated, end result will be</a>
<a name="ln464"> *</a>
<a name="ln465"> * -&gt; Temperature, timestamp, acceleration from LIS2DH12</a>
<a name="ln466"> * -&gt; RD_FLOAT_INVALID on humidity and pressure.</a>
<a name="ln467"> *</a>
<a name="ln468"> * @param[out] target Data to be populated. Fields must be initially populated with</a>
<a name="ln469"> *                    RD_FLOAT_INVALID.</a>
<a name="ln470"> * @param[in]  provided Data provided by sensor.</a>
<a name="ln471"> * @param[in]  requested Fields to be filled if possible.</a>
<a name="ln472"> */</a>
<a name="ln473">void rd_sensor_data_populate (rd_sensor_data_t * const target,</a>
<a name="ln474">                              const rd_sensor_data_t * const provided,</a>
<a name="ln475">                              const rd_sensor_data_fields_t requested);</a>
<a name="ln476"> </a>
<a name="ln477">/**</a>
<a name="ln478"> * @brief Parse data from provided struct.</a>
<a name="ln479"> *</a>
<a name="ln480"> * @param[in]  provided Data to be parsed.</a>
<a name="ln481"> * @param[in]  requested One data field to be parsed.</a>
<a name="ln482"> * @return     sensor value if found, RD_FLOAT_INVALID if the provided data didn't</a>
<a name="ln483"> *             have a valid value.</a>
<a name="ln484"> */</a>
<a name="ln485">float rd_sensor_data_parse (const rd_sensor_data_t * const provided,</a>
<a name="ln486">                            const rd_sensor_data_fields_t requested);</a>
<a name="ln487"> </a>
<a name="ln488">/**</a>
<a name="ln489"> * @brief Count number of floats required for this data structure.</a>
<a name="ln490"> *</a>
<a name="ln491"> * @param[in]  target Structure to count number of fields from.</a>
<a name="ln492"> * @return     Number of floats required to store the sensor data.</a>
<a name="ln493"> */</a>
<a name="ln494">uint8_t rd_sensor_data_fieldcount (const rd_sensor_data_t * const target);</a>
<a name="ln495"> </a>
<a name="ln496">/**</a>
<a name="ln497"> * @brief Set a desired value to target data.</a>
<a name="ln498"> *</a>
<a name="ln499"> * This function looks up the appropriate assigments on each data field in given target</a>
<a name="ln500"> * and populates it with provided data. Does nothing if there is no appropriate slot</a>
<a name="ln501"> * in target data.</a>
<a name="ln502"> *</a>
<a name="ln503"> * This is a shorthand for @ref rd_sensor_data_populate for only one data field, without</a>
<a name="ln504"> * setting timestamp.</a>
<a name="ln505"> *</a>
<a name="ln506"> * @param[out] target</a>
<a name="ln507"> * @param[in]  field  Quantity to set, exactly one must be set to true.</a>
<a name="ln508"> * @param[in]  value  Value of quantity,</a>
<a name="ln509"> */</a>
<a name="ln510">void rd_sensor_data_set (rd_sensor_data_t * const target,</a>
<a name="ln511">                         const rd_sensor_data_fields_t field,</a>
<a name="ln512">                         const float value);</a>
<a name="ln513"> </a>
<a name="ln514">/**</a>
<a name="ln515"> * @brief Validate that given setting can be set on a sensor which supports only default value.</a>
<a name="ln516"> *</a>
<a name="ln517"> * @param[in,out] input Input: Must be RD_SENSOR_CFG_DEFAULT, _NO_CHANGE, _MIN or _MAX.</a>
<a name="ln518"> *                      Output: _DEFAULT</a>
<a name="ln519"> * @param[in] mode Mode sensor is currently in. Must be sleep to configure sensor.</a>
<a name="ln520"> */</a>
<a name="ln521">rd_status_t validate_default_input_set (uint8_t * const input, const uint8_t mode);</a>
<a name="ln522"> </a>
<a name="ln523">/**</a>
<a name="ln524"> * @brief Validate and get input when only allowed value is default.</a>
<a name="ln525"> *</a>
<a name="ln526"> * @param[out] input Setting of sensor to get. Will be RD_SENSOR_CFG_DEFAULT.</a>
<a name="ln527"> *</a>
<a name="ln528"> * @retval RD_SUCCESS if input is not NULL.</a>
<a name="ln529"> * @retval RD_ERROR_NULL if input is NULL.</a>
<a name="ln530"> */</a>
<a name="ln531">rd_status_t validate_default_input_get (uint8_t * const input);</a>
<a name="ln532"> </a>
<a name="ln533">/*@}*/</a>
<a name="ln534">#endif</a>

</code></pre>
<div class="balloon" rel="117"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2572/" target="_blank">V2572</a> The value of the '1U' expression should not be converted from the essential 'unsigned' type to the essential 'rd_bus_t' type.</p></div>
<div class="balloon" rel="118"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2572/" target="_blank">V2572</a> The value of the '2U' expression should not be converted from the essential 'unsigned' type to the essential 'rd_bus_t' type.</p></div>
<div class="balloon" rel="119"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2572/" target="_blank">V2572</a> The value of the '3U' expression should not be converted from the essential 'unsigned' type to the essential 'rd_bus_t' type.</p></div>
<div class="balloon" rel="120"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2572/" target="_blank">V2572</a> The value of the '4U' expression should not be converted from the essential 'unsigned' type to the essential 'rd_bus_t' type.</p></div>
<div class="balloon" rel="121"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2572/" target="_blank">V2572</a> The value of the '5U' expression should not be converted from the essential 'unsigned' type to the essential 'rd_bus_t' type.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
