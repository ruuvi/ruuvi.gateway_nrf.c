
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>ruuvi_driver_sensor.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">#ifndef RUUVI_DRIVER_SENSOR_H</a>
<a name="ln2">#define RUUVI_DRIVER_SENSOR_H</a>
<a name="ln3">/**</a>
<a name="ln4"> * @defgroup Sensor Common sensor interface</a>
<a name="ln5"> * @brief Functions for setting up and using sensors</a>
<a name="ln6"> *</a>
<a name="ln7"> *</a>
<a name="ln8"> */</a>
<a name="ln9">/** @{ */</a>
<a name="ln10">/**</a>
<a name="ln11"> * @file ruuvi_driver_sensor.h</a>
<a name="ln12"> * @author Otso Jousimaa &lt;otso@ojousima.net&gt;</a>
<a name="ln13"> * @date 2020-06-01</a>
<a name="ln14"> * @copyright Ruuvi Innovations Ltd, license BSD-3-Clause</a>
<a name="ln15"> * @brief Ruuvi sensor interface &lt;b&gt;Lifecycle: Beta&lt;/b&gt;</a>
<a name="ln16"> *</a>
<a name="ln17"> *</a>
<a name="ln18"> *</a>
<a name="ln19"> * Common interface to all Ruuvi Sensors</a>
<a name="ln20"> * Every sensor must implement these functions:</a>
<a name="ln21"> * - init</a>
<a name="ln22"> * - uninit</a>
<a name="ln23"> * - samplerate_set</a>
<a name="ln24"> * - samplerate_get</a>
<a name="ln25"> * - dsp_set</a>
<a name="ln26"> * - dsp_get</a>
<a name="ln27"> * - scale_set</a>
<a name="ln28"> * - scale_set</a>
<a name="ln29"> * - resolution_set</a>
<a name="ln30"> * - resolution_get</a>
<a name="ln31"> * - mode_set</a>
<a name="ln32"> * - mode_get</a>
<a name="ln33"> * - data_get</a>
<a name="ln34"> *</a>
<a name="ln35"> * If function does not make sense for the sensor, it will return error code.</a>
<a name="ln36"> *</a>
<a name="ln37"> * Return name: Return a pointer to a constant 8-byte long string which represensts sensor, e.g. LIS2DH12\0 or BME280\0\0</a>
<a name="ln38"> *</a>
<a name="ln39"> * INIT, UNINT: Init will prepare sensor for use, reset the sensor, run self-test and place it in low-power mode. Additionally function pointers will be set up by init.</a>
<a name="ln40"> *              Uninit will release any resources used by sensor</a>
<a name="ln41"> *</a>
<a name="ln42"> * Samplerate: Applicable on continuous mode, how often sensor takes samples. Hz</a>
<a name="ln43"> *</a>
<a name="ln44"> * DSP: DSP function and parameter, i.e. &quot;OVERSAMPLING, 16&quot;. Return error if the device does not support it.</a>
<a name="ln45"> *</a>
<a name="ln46"> * scale: Maximum scale in a meaningful physical unit, such as celcius or pascal.</a>
<a name="ln47"> *</a>
<a name="ln48"> * resolution: Resolution in bits.</a>
<a name="ln49"> *</a>
<a name="ln50"> * mode: Sleep, single, continuous.</a>
<a name="ln51"> *  - Sleep mode should enter lowest-power state available</a>
<a name="ln52"> *  - Single will return once new data is available with data_get call</a>
<a name="ln53"> *  - Continuous: Sensor will sample at given rate. Returns immediately, data will be available after first sample</a>
<a name="ln54"> *</a>
<a name="ln55"> * data get: return latest sample from sensor</a>
<a name="ln56"> */</a>
<a name="ln57"> </a>
<a name="ln58">#include &quot;ruuvi_driver_error.h&quot;</a>
<a name="ln59">#include &lt;stdbool.h&gt;</a>
<a name="ln60">#include &lt;stddef.h&gt;</a>
<a name="ln61">#include &lt;stdint.h&gt;</a>
<a name="ln62"> </a>
<a name="ln63">#define RD_SENSOR_INVALID_VALUE    RD_FLOAT_INVALID  //!&lt; Signal this sensor value is erroneous</a>
<a name="ln64">#define RD_SENSOR_INVALID_TIMSTAMP RD_UINT64_INVALID //!&lt; Signal this timestamp value is erroneous</a>
<a name="ln65"> </a>
<a name="ln66">// Constants for sensor configuration and status</a>
<a name="ln67">#define RD_SENSOR_CFG_DEFAULT         (0U)      //!&lt; Default value, always valid for the sensor.</a>
<a name="ln68">#define RD_SENSOR_CFG_CUSTOM_1        (0xC9U)   //!&lt; Configuration range is 0...200, i.e. 0 ... 0xC8. Use C9 ... CF as sensor-specific values.</a>
<a name="ln69">#define RD_SENSOR_CFG_CUSTOM_2        (0xCAU)   //!&lt; Configuration range is 0...200, i.e. 0 ... 0xC8. Use C9 ... CF as sensor-specific values.</a>
<a name="ln70">#define RD_SENSOR_CFG_CUSTOM_3        (0xCBU)   //!&lt; Configuration range is 0...200, i.e. 0 ... 0xC8. Use C9 ... CF as sensor-specific values.</a>
<a name="ln71">#define RD_SENSOR_CFG_CUSTOM_4        (0xCCU)   //!&lt; Configuration range is 0...200, i.e. 0 ... 0xC8. Use C9 ... CF as sensor-specific values.</a>
<a name="ln72">#define RD_SENSOR_CFG_CUSTOM_5        (0xCDU)   //!&lt; Configuration range is 0...200, i.e. 0 ... 0xC8. Use C9 ... CF as sensor-specific values.</a>
<a name="ln73">#define RD_SENSOR_CFG_CUSTOM_6        (0xCEU)   //!&lt; Configuration range is 0...200, i.e. 0 ... 0xC8. Use C9 ... CF as sensor-specific values.</a>
<a name="ln74">#define RD_SENSOR_ERR_INVALID         (0xE0U)   //!&lt; Error code, given parameter is invalid</a>
<a name="ln75">#define RD_SENSOR_ERR_NOT_IMPLEMENTED (0xE1U)   //!&lt; Error code, given parameter is not implemented (todo)</a>
<a name="ln76">#define RD_SENSOR_ERR_NOT_SUPPORTED   (0xE2U)   //!&lt; Error code, given parameter is not supported by sensor</a>
<a name="ln77">#define RD_SENSOR_CFG_MIN             (0xF0U)   //!&lt; Configure smallest supported and implemented value</a>
<a name="ln78">#define RD_SENSOR_CFG_MAX             (0xF1U)   //!&lt; Configure largest supported and implemented value</a>
<a name="ln79">#define RD_SENSOR_CFG_SLEEP           (0xF2U)   //!&lt; Sensor should go to sleep immediately</a>
<a name="ln80">#define RD_SENSOR_CFG_SINGLE          (0xF3U)   //!&lt; Sensor should go to sleep after single measurement</a>
<a name="ln81">#define RD_SENSOR_CFG_CONTINUOUS      (0xF4U)   //!&lt; Sensor will keep sampling at defined sample rate</a>
<a name="ln82">#define RD_SENSOR_CFG_NO_CHANGE       (0xFFU)   //!&lt; Do not change configured value</a>
<a name="ln83"> </a>
<a name="ln84">// DSP functions, complemented by DSP parameter</a>
<a name="ln85">#define RD_SENSOR_DSP_LAST            (0U)    //!&lt; Return last value from sensor. Parameter: No effect. Use default</a>
<a name="ln86">#define RD_SENSOR_DSP_LOW_PASS        (1U&lt;&lt;1U) //!&lt; Low pass sensor values Parameter: coefficient</a>
<a name="ln87">#define RD_SENSOR_DSP_HIGH_PASS       (1U&lt;&lt;2U) //!&lt; High pass sensor values Parameter: coefficient</a>
<a name="ln88">#define RD_SENSOR_DSP_OS              (1U&lt;&lt;3U) //!&lt; Oversample sensor values. Parameter: Number of samples</a>
<a name="ln89"> </a>
<a name="ln90">/** @brief convert Ruuvi GPIO into uint8_t */</a>
<a name="ln91">#define RD_GPIO_TO_HANDLE(handle) ((((handle) &gt;&gt; 3U) &amp; 0xE0U) + ((handle) &amp; 0x1FU))</a>
<a name="ln92">/** @brief convert uint8_t into Ruuvi GPIO */</a>
<a name="ln93">#define RD_HANDLE_TO_GPIO(handle) ((((handle) &amp; 0xE0U) &lt;&lt; 3U) + ((handle) &amp; 0x1FU))</a>
<a name="ln94"> </a>
<a name="ln95">/**</a>
<a name="ln96"> * @brief All sensors must implement configuration functions which accept this struct.</a>
<a name="ln97"> */</a>
<a name="ln98">typedef struct __attribute__ ( (packed, aligned (4)))</a>
<a name="ln99">{</a>
<a name="ln100">    uint8_t samplerate;     //!&lt; Samplerate, in Hz</a>
<a name="ln101">    uint8_t resolution;     //!&lt; Resolution, in bits</a>
<a name="ln102">    uint8_t scale;          //!&lt; Scale, in relevant Si-unit</a>
<a name="ln103">    uint8_t dsp_function;   //!&lt; DSP function, one of @c RD_SENSOR_DSP_*</a>
<a name="ln104">    uint8_t dsp_parameter;  //!&lt; Parameter to DSP functions</a>
<a name="ln105">    uint8_t mode;           //!&lt; Mode, RD_SENSOR_SLEEP, _SINGLE, _CONTINOUS</a>
<a name="ln106">    uint8_t reserved0;      //!&lt; Reserved for future use</a>
<a name="ln107">    uint8_t reserved1;      //!&lt; Reserved for future use</a>
<a name="ln108">}</a>
<a name="ln109">rd_sensor_configuration_t;</a>
<a name="ln110"> </a>
<a name="ln111">/**</a>
<a name="ln112"> * @brief Type of bus sensor uses.</a>
<a name="ln113"> */</a>
<a name="ln114">typedef enum</a>
<a name="ln115">{</a>
<a name="ln116">    RD_BUS_NONE = 0U, //!&lt; No bus, internal to IC</a>
<a name="ln117">    RD_BUS_SPI  = 1U, //!&lt; SPI bus</a>
<a name="ln118">    RD_BUS_I2C  = 2U, //!&lt; I2C bus</a>
<a name="ln119">    RD_BUS_UART = 3U, //!&lt; UART bus</a>
<a name="ln120">    RD_BUS_PDM  = 4U, //!&lt; PDM bus</a>
<a name="ln121">    RD_BUS_FAIL = 5U  //!&lt; Test behaviour on invalid bus with this value.</a>
<a name="ln122">} rd_bus_t;</a>
<a name="ln123"> </a>
<a name="ln124">/**</a>
<a name="ln125"> * @brief Bitfield to describe related sensor data</a>
<a name="ln126"> */</a>
<a name="ln127">typedef struct</a>
<a name="ln128">{</a>
<a name="ln129">    unsigned int acceleration_x_g : 1; //!&lt; Acceleration along X-axis, gravities.</a>
<a name="ln130">    unsigned int acceleration_y_g : 1; //!&lt; Acceleration along Y-axis, gravities.</a>
<a name="ln131">    unsigned int acceleration_z_g : 1; //!&lt; Acceleration along Z-axis, gravities.</a>
<a name="ln132">    unsigned int co2_ppm : 1;          //!&lt; CO2, Parts per million.</a>
<a name="ln133">    unsigned int gyro_x_dps : 1;       //!&lt; Rotation along X-axis, degrees per second.</a>
<a name="ln134">    unsigned int gyro_y_dps : 1;       //!&lt; Rotation along Y-axis, degrees per second.</a>
<a name="ln135">    unsigned int gyro_z_dps : 1;       //!&lt; Rotation along Z-axis, degrees per second.</a>
<a name="ln136">    unsigned int humidity_rh : 1;      //!&lt; Relative humidity, %.</a>
<a name="ln137">    /** @brief Light level, dimensionless. Comparable only between identical devices. */</a>
<a name="ln138">    unsigned int luminosity  : 1;</a>
<a name="ln139">    unsigned int magnetometer_x_g : 1; //!&lt; Magnetic flux along X-axis, Gauss.</a>
<a name="ln140">    unsigned int magnetometer_y_g : 1; //!&lt; Magnetic flux along Y-axis, Gauss.</a>
<a name="ln141">    unsigned int magnetometer_z_g : 1; //!&lt; Magnetic flux along Z-axis, Gauss.</a>
<a name="ln142">    unsigned int pm_1_ugm3 : 1;        //!&lt; Ultra-fine particulate matter, microgram per m^3.</a>
<a name="ln143">    unsigned int pm_2_ugm3 : 1;        //!&lt; Fine particulate matter, microgram per m^3.</a>
<a name="ln144">    unsigned int pm_4_ugm3 : 1;        //!&lt; Medium particulate matter, microgram per m^3.</a>
<a name="ln145">    unsigned int pm_10_ugm3 : 1;       //!&lt; Coarse particulate matter, microgram per m^3.</a>
<a name="ln146">    unsigned int pressure_pa : 1;      //!&lt; Pressure, pascals</a>
<a name="ln147">    unsigned int spl_dbz : 1;          //!&lt; Unweighted sound pressure level.</a>
<a name="ln148">    unsigned int temperature_c : 1;    //!&lt; Temperature, celcius</a>
<a name="ln149">    unsigned int voc_ppm : 1;          //!&lt; Volatile organic compounds, parts per million.</a>
<a name="ln150">    unsigned int voltage_v : 1;        //!&lt; Voltage, volts.</a>
<a name="ln151">    unsigned int voltage_ratio : 1;    //!&lt; Voltage, ratio to maximum</a>
<a name="ln152">} rd_sensor_data_bitfield_t;</a>
<a name="ln153"> </a>
<a name="ln154">/**</a>
<a name="ln155"> * C99 Standard 6.7.8.21</a>
<a name="ln156"> * If there are fewer initializers in a brace-enclosed list than there are</a>
<a name="ln157"> * elements or members of an aggregate, or fewer characters in a string literal</a>
<a name="ln158"> * used to initialize an array of known size than there are elements in the array,</a>
<a name="ln159"> * the remainder of the aggregate shall be initialized implicitly the same as</a>
<a name="ln160"> * objects that have static storage duration.</a>
<a name="ln161"> */</a>
<a name="ln162">/** @brief Shorthand for calling rd_sensor_data_parse(p_data, FIELD) */</a>
<a name="ln163">#define RD_SENSOR_ACC_X_FIELD ((rd_sensor_data_fields_t){.datas.acceleration_x_g=1})</a>
<a name="ln164">/** @brief Shorthand for calling rd_sensor_data_parse(p_data, FIELD) */</a>
<a name="ln165">#define RD_SENSOR_ACC_Y_FIELD ((rd_sensor_data_fields_t){.datas.acceleration_y_g=1})</a>
<a name="ln166">/** @brief Shorthand for calling rd_sensor_data_parse(p_data, FIELD) */</a>
<a name="ln167">#define RD_SENSOR_ACC_Z_FIELD ((rd_sensor_data_fields_t){.datas.acceleration_z_g=1})</a>
<a name="ln168">/** @brief Shorthand for calling rd_sensor_data_parse(p_data, FIELD) */</a>
<a name="ln169">#define RD_SENSOR_HUMI_FIELD ((rd_sensor_data_fields_t){.datas.humidity_rh=1})</a>
<a name="ln170">/** @brief Shorthand for calling rd_sensor_data_parse(p_data, FIELD) */</a>
<a name="ln171">#define RD_SENSOR_PRES_FIELD ((rd_sensor_data_fields_t){.datas.pressure_pa=1})</a>
<a name="ln172">/** @brief Shorthand for calling rd_sensor_data_parse(p_data, FIELD) */</a>
<a name="ln173">#define RD_SENSOR_TEMP_FIELD ((rd_sensor_data_fields_t){.datas.temperature_c=1})</a>
<a name="ln174"> </a>
<a name="ln175"> </a>
<a name="ln176"> </a>
<a name="ln177">/**</a>
<a name="ln178"> * @brief Union to access sensor data.</a>
<a name="ln179"> *</a>
<a name="ln180"> * MISRA deviation: Use of union.</a>
<a name="ln181"> * Union is used here for fast operations on sensor data through field bitfield</a>
<a name="ln182"> * and to give a meaningful value to each bit through datas.</a>
<a name="ln183"> *</a>
<a name="ln184"> * C99 and onwards allow type punning, but this is not portable to C++.</a>
<a name="ln185"> * Run the integration tests on your platform.</a>
<a name="ln186"> *</a>
<a name="ln187"> */</a>
<a name="ln188">typedef union // -V2514</a>
<a name="ln189">{</a>
<a name="ln190">    uint32_t bitfield; //!&lt; Bitfield used to access sensor data.</a>
<a name="ln191">    rd_sensor_data_bitfield_t datas; //!&lt; Structured data field.</a>
<a name="ln192">} rd_sensor_data_fields_t;</a>
<a name="ln193"> </a>
<a name="ln194">/**</a>
<a name="ln195"> * @brief Generic sensor data struct.</a>
<a name="ln196"> *</a>
<a name="ln197"> * The data sensor struct contains a timestamp relative to sensor boot,</a>
<a name="ln198"> * a list of fields contained within the sensor data and a pointer to array</a>
<a name="ln199"> * of floats which contain the actual data.</a>
<a name="ln200"> */</a>
<a name="ln201">typedef struct rd_sensor_data_t</a>
<a name="ln202">{</a>
<a name="ln203">    uint64_t timestamp_ms;      //!&lt; Timestamp of the event, @ref rd_sensor_timestamp_get.</a>
<a name="ln204">    rd_sensor_data_fields_t</a>
<a name="ln205">    fields; //!&lt; Description of datafields which may be contained in this sample.</a>
<a name="ln206">    rd_sensor_data_fields_t valid;  //!&lt; Listing of valid data in this sample.</a>
<a name="ln207">    /** @brief Data of sensor. Must contain as many elements as fields has bits set. */</a>
<a name="ln208">    float * data;</a>
<a name="ln209">} rd_sensor_data_t;</a>
<a name="ln210"> </a>
<a name="ln211">/** @brief Forward declare type definition of sensor structure */</a>
<a name="ln212">typedef struct rd_sensor_t rd_sensor_t;</a>
<a name="ln213"> </a>
<a name="ln214">/**</a>
<a name="ln215"> * @brief Initialize and uninitialize sensor.</a>
<a name="ln216"> * Init and uninit will setup sensor with function pointers.</a>
<a name="ln217"> * The sensor wil be initialized to lowest power state possible.</a>
<a name="ln218"> *</a>
<a name="ln219"> * @param[in,out] p_sensor pointer to sensor structure</a>
<a name="ln220"> * @param[in] bus bus to use, i.r. I2C or SPI</a>
<a name="ln221"> * @param[in] handle for the sensor, for example I2C address or SPI chip select pin</a>
<a name="ln222"> * @return @c RD_SUCCESS on success</a>
<a name="ln223"> * @return @c RD_ERROR_NULL if p_sensor is NULL</a>
<a name="ln224"> * @return @c RD_ERROR_NOT_FOUND if there is no response from sensor or if ID of</a>
<a name="ln225"> *            a sensor read over bus does not match expected value</a>
<a name="ln226"> * @return @c RD_ERROR_SELFTEST if sensor is found but it does not pass selftest</a>
<a name="ln227"> * @return @c RD_ERROR_INVALID_STATE if trying to initialize sensor which</a>
<a name="ln228"> *            already has been initialized.</a>
<a name="ln229"> **/</a>
<a name="ln230">typedef rd_status_t (*rd_sensor_init_fp) (rd_sensor_t * const</a>
<a name="ln231">        p_sensor, const rd_bus_t bus, const uint8_t handle);</a>
<a name="ln232"> </a>
<a name="ln233">/**</a>
<a name="ln234"> *  @brief Setup a parameter of a sensor.</a>
<a name="ln235"> *  The function will modify the pointed data to the actual value which was written</a>
<a name="ln236"> *</a>
<a name="ln237"> *  @param[in,out] parameter value to write to sensor configuration. Actual value written to sensor as output</a>
<a name="ln238"> *  @return RD_SUCCESS on success</a>
<a name="ln239"> *  @return RD_ERROR_NULL if parameter is NULL</a>
<a name="ln240"> *  @return RD_ERROR_NOT_SUPPORTED if sensor cannot support given parameter</a>
<a name="ln241"> *  @return RD_ERROR_NOT_IMPLEMENTED if the sensor could support parameter, but it's not implemented in fw.</a>
<a name="ln242"> **/</a>
<a name="ln243">typedef rd_status_t (*rd_sensor_setup_fp) (uint8_t * parameter);</a>
<a name="ln244"> </a>
<a name="ln245">/**</a>
<a name="ln246"> * @brief Configure sensor digital signal processing.</a>
<a name="ln247"> * Takes DSP function and a DSP parameter as input, configured value or error code as output.</a>
<a name="ln248"> * Modifies input parameters to actual values written on the sensor.</a>
<a name="ln249"> * DSP functions are run on the sensor HW, not in the platform FW.</a>
<a name="ln250"> *</a>
<a name="ln251"> * @param[in,out] dsp_function. DSP function to run on sensor. Can be a combination of several functions.</a>
<a name="ln252"> * @param[in,out] dsp_parameter. Parameter to DSP function(s)</a>
<a name="ln253"> * @return RD_SUCCESS on success</a>
<a name="ln254"> * @return RD_ERROR_NULL if either parameter is NULL</a>
<a name="ln255"> * @return RD_ERROR_NOT_SUPPORTED if sensor doesn't support given DSP</a>
<a name="ln256"> * @return RD_ERROR_NOT_IMPLEMENTED if sensor supports given DSP, but</a>
<a name="ln257"> *         driver does not implement it</a>
<a name="ln258"> * @return RD_ERROR_INVALID_PARAM if parameter is invalid for any reason.</a>
<a name="ln259"> **/</a>
<a name="ln260">typedef rd_status_t (*rd_sensor_dsp_fp) (uint8_t * dsp_function,</a>
<a name="ln261">        uint8_t * dsp_parameter);</a>
<a name="ln262"> </a>
<a name="ln263">/**</a>
<a name="ln264"> * @brief Read latest data from sensor registers</a>
<a name="ln265"> * Return latest data from sensor. Does not take a new sample, calling this function twice</a>
<a name="ln266"> * in a row returns same data. Configure sensor in a single-shot mode to take a new sample</a>
<a name="ln267"> * or leave sensor in a continuous mode to get updated data.</a>
<a name="ln268"> *</a>
<a name="ln269"> * @param [out] p_data Pointer to sensor data @ref rd_sensor_data_t .</a>
<a name="ln270"> * @return RD_SUCCESS on success</a>
<a name="ln271"> * @return RD_ERROR_NULL if p_data is @c NULL.</a>
<a name="ln272"> *</a>
<a name="ln273"> * @warning if sensor data is not valid for any reason, data is populated with</a>
<a name="ln274"> *          @c RD_FLOAT_INVALID.</a>
<a name="ln275"> */</a>
<a name="ln276">typedef rd_status_t (*rd_sensor_data_fp) (rd_sensor_data_t * const p_data);</a>
<a name="ln277"> </a>
<a name="ln278">/**</a>
<a name="ln279"> * @brief Convenience function to write/read entire configuration in one call.</a>
<a name="ln280"> * Modifies input parameters to actual values written on the sensor.</a>
<a name="ln281"> *</a>
<a name="ln282"> * @param[in] p_sensor sensor to configure</a>
<a name="ln283"> * @param[in,out] p_configuration Input: desired configuration. Output:</a>
<a name="ln284"> *                configuration written to sensot.</a>
<a name="ln285"> * @retval RD_SUCCESS if sensor was configured successfully.</a>
<a name="ln286"> * @retval RD_ERROR_NULL if one of parameters is NULL</a>
<a name="ln287"> * @return Error code from driver on other error.</a>
<a name="ln288"> **/</a>
<a name="ln289">typedef rd_status_t (*rd_configuration_fp) (</a>
<a name="ln290">    const rd_sensor_t * const p_sensor,</a>
<a name="ln291">    rd_sensor_configuration_t * const p_configuration);</a>
<a name="ln292"> </a>
<a name="ln293">/**</a>
<a name="ln294">* @brief Read First-in-first-out (FIFO) buffer in sensor.</a>
<a name="ln295">* Reads up to num_elements data points from FIFO and populates pointer data with them.</a>
<a name="ln296">*</a>
<a name="ln297">* @param[in, out] num_elements Input: number of elements in data.</a>
<a name="ln298">                               Output: Number of elements placed in data.</a>
<a name="ln299">* @param[out] Data array of  with num_elements slots.</a>
<a name="ln300">* @retval RD_SUCCESS on success.</a>
<a name="ln301">* @retval RD_ERROR_NULL if either parameter is NULL.</a>
<a name="ln302">* @retval RD_ERROR_INVALID_STATE if FIFO is not in use.</a>
<a name="ln303">* @retval RD_ERROR_NOT_SUPPORTED if the sensor does not have FIFO.</a>
<a name="ln304">* @return error code from stack on error.</a>
<a name="ln305">*/</a>
<a name="ln306">typedef rd_status_t (*rd_sensor_fifo_read_fp) (size_t * const num_elements,</a>
<a name="ln307">        rd_sensor_data_t * const data);</a>
<a name="ln308"> </a>
<a name="ln309">/**</a>
<a name="ln310">* @brief Enable FIFO or FIFO interrupt full interrupt on sensor.</a>
<a name="ln311">* FIFO interrupt Triggers an interrupt once FIFO is filled.</a>
<a name="ln312">* It is responsibility of application to know the routing of and polarity of GPIO pins and</a>
<a name="ln313">* configure the GPIO to register interrupts.</a>
<a name="ln314">*</a>
<a name="ln315">* @param[in] enable True to enable interrupt, false to disable interrupt</a>
<a name="ln316">* @return RD_SUCCESS on success, error code from stack otherwise.</a>
<a name="ln317">**/</a>
<a name="ln318">typedef rd_status_t (*rd_sensor_fifo_enable_fp) (const bool enable);</a>
<a name="ln319"> </a>
<a name="ln320">/**</a>
<a name="ln321">* @brief Enable level interrupt on sensor.</a>
<a name="ln322">*</a>
<a name="ln323">* Triggers as ACTIVE HIGH interrupt while detected data is above threshold.</a>
<a name="ln324">*</a>
<a name="ln325">* Trigger is symmetric, i.e. threshold is valid for above positive or below negative</a>
<a name="ln326">* of given value.</a>
<a name="ln327">*</a>
<a name="ln328">* On accelerometer data is high-passed to filter out gravity.</a>
<a name="ln329">* Axes are examined individually, compound data won't trigger the interrupt. e.g.</a>
<a name="ln330">* accelerometer showing 0.8 G along X, Y, Z axes won't trigger at threshold of 1 G,</a>
<a name="ln331">* even though the vector sum of axes is larger than 1 G.</a>
<a name="ln332">*</a>
<a name="ln333">* It is responsibility of application to know the GPIO routing and register</a>
<a name="ln334">* GPIO interrupts.</a>
<a name="ln335">*</a>
<a name="ln336">* @param[in] enable  True to enable interrupt, false to disable interrupt</a>
<a name="ln337">* @param[in,out] limit_g: Input: Desired acceleration to trigger the interrupt.</a>
<a name="ln338">*                         Is considered as &quot;at least&quot;, the acceleration is rounded up to</a>
<a name="ln339">*                         next value.</a>
<a name="ln340">*                         Output: written with value that was set to interrupt</a>
<a name="ln341">* @retval RD_SUCCESS on success.</a>
<a name="ln342">* @retval RD_INVALID_STATE if data limit is higher than maximum scale.</a>
<a name="ln343">* @return error code from stack on error.</a>
<a name="ln344">*</a>
<a name="ln345">*/</a>
<a name="ln346">typedef rd_status_t (*rd_sensor_level_interrupt_use_fp) (const bool enable,</a>
<a name="ln347">        float * limit_g);</a>
<a name="ln348"> </a>
<a name="ln349">/**</a>
<a name="ln350"> * @brief Return number of milliseconds since the start of RTC.</a>
<a name="ln351"> *</a>
<a name="ln352"> * @return milliseconds since start of RTC.</a>
<a name="ln353"> * @return RD_UINT64T_INVALID if RTC is not running</a>
<a name="ln354"> */</a>
<a name="ln355">typedef uint64_t (*rd_sensor_timestamp_fp) (void);</a>
<a name="ln356"> </a>
<a name="ln357">/**</a>
<a name="ln358"> * @brief Interface to sensor.</a>
<a name="ln359"> * Some sensors can implement additional functions.</a>
<a name="ln360"> * The additional functions are defined in the interface of the sensor.</a>
<a name="ln361"> */</a>
<a name="ln362">typedef struct rd_sensor_t</a>
<a name="ln363">{</a>
<a name="ln364">    /** @brief sensor human-readable name. Should be at most 8 bytes long. */</a>
<a name="ln365">    const char * name;</a>
<a name="ln366">    /** @brief Description of data fields the sensor is able to provide. */</a>
<a name="ln367">    rd_sensor_data_fields_t provides;</a>
<a name="ln368">    /** @brief @ref rd_sensor_init_fp */</a>
<a name="ln369">    rd_sensor_init_fp   init;</a>
<a name="ln370">    /** @brief @ref rd_sensor_init_fp */</a>
<a name="ln371">    rd_sensor_init_fp   uninit;</a>
<a name="ln372">    /** @brief @ref rd_sensor_setup_fp */</a>
<a name="ln373">    rd_sensor_setup_fp samplerate_set;</a>
<a name="ln374">    /** @brief @ref rd_sensor_setup_fp */</a>
<a name="ln375">    rd_sensor_setup_fp samplerate_get;</a>
<a name="ln376">    /** @brief @ref rd_sensor_setup_fp */</a>
<a name="ln377">    rd_sensor_setup_fp resolution_set;</a>
<a name="ln378">    /** @brief @ref rd_sensor_setup_fp */</a>
<a name="ln379">    rd_sensor_setup_fp resolution_get;</a>
<a name="ln380">    /** @brief @ref rd_sensor_setup_fp */</a>
<a name="ln381">    rd_sensor_setup_fp scale_set;</a>
<a name="ln382">    /** @brief @ref rd_sensor_setup_fp */</a>
<a name="ln383">    rd_sensor_setup_fp scale_get;</a>
<a name="ln384">    /** @brief @ref rd_sensor_setup_fp */</a>
<a name="ln385">    rd_sensor_setup_fp mode_set;</a>
<a name="ln386">    /** @brief @ref rd_sensor_setup_fp */</a>
<a name="ln387">    rd_sensor_setup_fp mode_get;</a>
<a name="ln388">    /** @brief @ref rd_sensor_dsp_fp */</a>
<a name="ln389">    rd_sensor_dsp_fp   dsp_set;</a>
<a name="ln390">    /** @brief @ref rd_sensor_dsp_fp */</a>
<a name="ln391">    rd_sensor_dsp_fp   dsp_get;</a>
<a name="ln392">    /** @brief @ref rd_configuration_fp */</a>
<a name="ln393">    rd_configuration_fp configuration_set;</a>
<a name="ln394">    /** @brief @ref rd_configuration_fp */</a>
<a name="ln395">    rd_configuration_fp configuration_get;</a>
<a name="ln396">    /** @brief @ref rd_sensor_data_fp */</a>
<a name="ln397">    rd_sensor_data_fp   data_get;</a>
<a name="ln398">    /** @brief @速ef rd_sensor_fifo_enable_fp */</a>
<a name="ln399">    rd_sensor_fifo_enable_fp fifo_enable;</a>
<a name="ln400">    /** @brief @速ef rd_sensor_level_interrupt_use_fp */</a>
<a name="ln401">    rd_sensor_fifo_enable_fp fifo_interrupt_enable;</a>
<a name="ln402">    /** @brief @速ef rd_sensor_level_interrupt_use_fp */</a>
<a name="ln403">    rd_sensor_fifo_read_fp   fifo_read;</a>
<a name="ln404">    /** @brief @速ef rd_sensor_level_interrupt_use_fp */</a>
<a name="ln405">    rd_sensor_level_interrupt_use_fp level_interrupt_set;</a>
<a name="ln406">} rd_sensor_t;</a>
<a name="ln407"> </a>
<a name="ln408">/**</a>
<a name="ln409"> * @brief Implementation of ref rd_configuration_fp</a>
<a name="ln410"> */</a>
<a name="ln411">rd_status_t rd_sensor_configuration_set (const rd_sensor_t *</a>
<a name="ln412">        sensor, rd_sensor_configuration_t * config);</a>
<a name="ln413"> </a>
<a name="ln414">/**</a>
<a name="ln415"> * @brief Implementation of ref rd_configuration_fp</a>
<a name="ln416"> */</a>
<a name="ln417">rd_status_t rd_sensor_configuration_get (const rd_sensor_t *</a>
<a name="ln418">        sensor, rd_sensor_configuration_t * config);</a>
<a name="ln419"> </a>
<a name="ln420">/**</a>
<a name="ln421"> * @brief Setup timestamping.</a>
<a name="ln422"> * Set to @c NULL to disable timestamps.</a>
<a name="ln423"> *</a>
<a name="ln424"> * @param[in] timestamp_fp Function pointer to @ref rd_sensor_timestamp_fp implementation</a>
<a name="ln425"> * @retval RD_SUCCESS.</a>
<a name="ln426"> */</a>
<a name="ln427">rd_status_t rd_sensor_timestamp_function_set (</a>
<a name="ln428">    const rd_sensor_timestamp_fp  timestamp_fp);</a>
<a name="ln429"> </a>
<a name="ln430">/**</a>
<a name="ln431"> * @brief Calls the timestamp function and returns its value.</a>
<a name="ln432"> * @return milliseconds since the start of RTC.</a>
<a name="ln433"> * @retval RD_UINT64_INVALID if timestamp function is NULL</a>
<a name="ln434"> */</a>
<a name="ln435">uint64_t rd_sensor_timestamp_get (void);</a>
<a name="ln436"> </a>
<a name="ln437">/**</a>
<a name="ln438"> * @brief Initialize sensor struct with non-null pointers which</a>
<a name="ln439"> *        return RD_ERROR_NOT_INITIALIZED.</a>
<a name="ln440"> *</a>
<a name="ln441"> * This function is to ensure that NULL function pointers won't be called.</a>
<a name="ln442"> * If name was NULL before calling this, name will point to &quot;NOTINIT&quot;.</a>
<a name="ln443"> * If name was already set, it won't be changed.</a>
<a name="ln444"> *</a>
<a name="ln445"> * @param[out] p_sensor pointer to sensor struct to initialize.</a>
<a name="ln446"> */</a>
<a name="ln447">void rd_sensor_initialize (rd_sensor_t * const p_sensor);</a>
<a name="ln448"> </a>
<a name="ln449">/**</a>
<a name="ln450"> * @brief Mark sensor as uninitialized by calling the generic initialization.</a>
<a name="ln451"> * Will not clear the name of the sensor.</a>
<a name="ln452"> *</a>
<a name="ln453"> * @param[out] p_sensor pointer to sensor struct to uninitialize.</a>
<a name="ln454"> */</a>
<a name="ln455">void rd_sensor_uninitialize (rd_sensor_t * const p_sensor);</a>
<a name="ln456"> </a>
<a name="ln457">/**</a>
<a name="ln458"> * @brief Check if given sensor structure is already initialized.</a>
<a name="ln459"> *</a>
<a name="ln460"> * @param[in] sensor Sensor interface to check.</a>
<a name="ln461"> * @return true if structure is initialized, false otherwise.</a>
<a name="ln462"> */</a>
<a name="ln463">bool rd_sensor_is_init (const rd_sensor_t * const sensor);</a>
<a name="ln464"> </a>
<a name="ln465">/**</a>
<a name="ln466"> * @brief Populate given target data with data provided by sensor as requested.</a>
<a name="ln467"> *</a>
<a name="ln468"> * This function looks up the appropriate assigments on each data field in given target</a>
<a name="ln469"> * and populates it with provided data if caller requested the field to be populated.</a>
<a name="ln470"> * Populated fields are marked as valid.</a>
<a name="ln471"> *</a>
<a name="ln472"> * Example: Board can have these sensors in this order of priority:</a>
<a name="ln473"> *  - TMP117 (temperature)</a>
<a name="ln474"> *  - SHTC3 (temperature, humidity)</a>
<a name="ln475"> *  - DPS310 (temperature, pressure)</a>
<a name="ln476"> *  - LIS2DH12 (acceleration, temperature)</a>
<a name="ln477"> *</a>
<a name="ln478"> * If a target with fields for temperature, humidity, pressure and acceleration is</a>
<a name="ln479"> * created and populated from data of the sensors end result will be:</a>
<a name="ln480"> *</a>
<a name="ln481"> * -&gt; Temperature, timestamp from TMP117</a>
<a name="ln482"> * -&gt; Humidity from SHTC3</a>
<a name="ln483"> * -&gt; Pressure from DPS310</a>
<a name="ln484"> * -&gt; Acceleration from LIS2DH12</a>
<a name="ln485"> *</a>
<a name="ln486"> * If same firmware is run on a board with only LIS2DH12 populated, end result will be</a>
<a name="ln487"> *</a>
<a name="ln488"> * -&gt; Temperature, timestamp, acceleration from LIS2DH12</a>
<a name="ln489"> * -&gt; RD_FLOAT_INVALID on humidity and pressure.</a>
<a name="ln490"> *</a>
<a name="ln491"> * @param[out] target Data to be populated. Fields must be initially populated with</a>
<a name="ln492"> *                    RD_FLOAT_INVALID.</a>
<a name="ln493"> * @param[in]  provided Data provided by sensor.</a>
<a name="ln494"> * @param[in]  requested Fields to be filled if possible.</a>
<a name="ln495"> */</a>
<a name="ln496">void rd_sensor_data_populate (rd_sensor_data_t * const target,</a>
<a name="ln497">                              const rd_sensor_data_t * const provided,</a>
<a name="ln498">                              const rd_sensor_data_fields_t requested);</a>
<a name="ln499"> </a>
<a name="ln500">/**</a>
<a name="ln501"> * @brief Parse data from provided struct.</a>
<a name="ln502"> *</a>
<a name="ln503"> * @param[in]  provided Data to be parsed.</a>
<a name="ln504"> * @param[in]  requested One data field to be parsed.</a>
<a name="ln505"> * @return     sensor value if found, RD_FLOAT_INVALID if the provided data didn't</a>
<a name="ln506"> *             have a valid value.</a>
<a name="ln507"> */</a>
<a name="ln508">float rd_sensor_data_parse (const rd_sensor_data_t * const provided,</a>
<a name="ln509">                            const rd_sensor_data_fields_t requested);</a>
<a name="ln510"> </a>
<a name="ln511">/**</a>
<a name="ln512"> * @brief Count number of floats required for this data structure.</a>
<a name="ln513"> *</a>
<a name="ln514"> * @param[in]  target Structure to count number of fields from.</a>
<a name="ln515"> * @return     Number of floats required to store the sensor data.</a>
<a name="ln516"> */</a>
<a name="ln517">uint8_t rd_sensor_data_fieldcount (const rd_sensor_data_t * const target);</a>
<a name="ln518"> </a>
<a name="ln519">/**</a>
<a name="ln520"> * @brief Set a desired value to target data.</a>
<a name="ln521"> *</a>
<a name="ln522"> * This function looks up the appropriate assigments on each data field in given target</a>
<a name="ln523"> * and populates it with provided data. Does nothing if there is no appropriate slot</a>
<a name="ln524"> * in target data.</a>
<a name="ln525"> *</a>
<a name="ln526"> * This is a shorthand for @ref rd_sensor_data_populate for only one data field, without</a>
<a name="ln527"> * setting timestamp.</a>
<a name="ln528"> *</a>
<a name="ln529"> * @param[out] target</a>
<a name="ln530"> * @param[in]  field  Quantity to set, exactly one must be set to true.</a>
<a name="ln531"> * @param[in]  value  Value of quantity,</a>
<a name="ln532"> */</a>
<a name="ln533">void rd_sensor_data_set (rd_sensor_data_t * const target,</a>
<a name="ln534">                         const rd_sensor_data_fields_t field,</a>
<a name="ln535">                         const float value);</a>
<a name="ln536"> </a>
<a name="ln537">/**</a>
<a name="ln538"> * @brief Validate that given setting can be set on a sensor which supports only default value.</a>
<a name="ln539"> *</a>
<a name="ln540"> * @param[in,out] input Input: Must be RD_SENSOR_CFG_DEFAULT, _NO_CHANGE, _MIN or _MAX.</a>
<a name="ln541"> *                      Output: _DEFAULT</a>
<a name="ln542"> * @param[in] mode Mode sensor is currently in. Must be sleep to configure sensor.</a>
<a name="ln543"> */</a>
<a name="ln544">rd_status_t validate_default_input_set (uint8_t * const input, const uint8_t mode);</a>
<a name="ln545"> </a>
<a name="ln546">/**</a>
<a name="ln547"> * @brief Validate and get input when only allowed value is default.</a>
<a name="ln548"> *</a>
<a name="ln549"> * @param[out] input Setting of sensor to get. Will be RD_SENSOR_CFG_DEFAULT.</a>
<a name="ln550"> *</a>
<a name="ln551"> * @retval RD_SUCCESS if input is not NULL.</a>
<a name="ln552"> * @retval RD_ERROR_NULL if input is NULL.</a>
<a name="ln553"> */</a>
<a name="ln554">rd_status_t validate_default_input_get (uint8_t * const input);</a>
<a name="ln555"> </a>
<a name="ln556">/**</a>
<a name="ln557"> * @brief Check if sensor has valid data at given index.</a>
<a name="ln558"> *</a>
<a name="ln559"> * Data is considered valid if target-&gt;fields and target-&gt;valid both are set.</a>
<a name="ln560"> * Index is referred to number of fields.</a>
<a name="ln561"> *</a>
<a name="ln562"> * Typical usage:</a>
<a name="ln563"> * @code</a>
<a name="ln564"> * const uint8_t fieldcount = rd_sensor_data_fieldcount(p_data);</a>
<a name="ln565"> * for(uint8_t ii = 0; ii &lt; fieldcount; ii++)</a>
<a name="ln566"> * {</a>
<a name="ln567"> *     if(rd_sensor_has_valid_data(p_data, ii)</a>
<a name="ln568"> *     {</a>
<a name="ln569"> *        do_stuff(p_data-&gt;data[ii], rd_sensor_field_type(p_data, ii));</a>
<a name="ln570"> *     }</a>
<a name="ln571"> * }</a>
<a name="ln572"> * @endcode</a>
<a name="ln573"> *</a>
<a name="ln574"> * @param[in] target Pointer to data to check.</a>
<a name="ln575"> * @param[in] index index of data to check.</a>
<a name="ln576"> * @retval true If data at target-&gt;data[index] has a valid value.</a>
<a name="ln577"> * @retval false If target is NULL, index is higher than fields in data or data at</a>
<a name="ln578"> *               index is not marked as valid.</a>
<a name="ln579"> *</a>
<a name="ln580"> * @note To determine the type of data, use @ref rd_sensor_field_type.</a>
<a name="ln581"> */</a>
<a name="ln582">bool rd_sensor_has_valid_data (const rd_sensor_data_t * const target,</a>
<a name="ln583">                               const uint8_t index);</a>
<a name="ln584"> </a>
<a name="ln585">/**</a>
<a name="ln586"> * @brief Check the type of data at given index.</a>
<a name="ln587"> *</a>
<a name="ln588"> * This function is used to determine what type of data given index has.</a>
<a name="ln589"> *</a>
<a name="ln590"> * Typical usage:</a>
<a name="ln591"> * @code</a>
<a name="ln592"> * rd_sensor_data_bitfield_t type = rd_sensor_field_type(p_data, index);</a>
<a name="ln593"> * if(1 == type.temperature_c)</a>
<a name="ln594"> * {</a>
<a name="ln595"> *    do_stuff_with_temperature (p_data-&gt;data[index])</a>
<a name="ln596"> * }</a>
<a name="ln597"> * @endcode</a>
<a name="ln598"> *</a>
<a name="ln599"> * @param[in] target Data to check</a>
<a name="ln600"> * @param[in] index  Index of field to check.</a>
<a name="ln601"> * @return rd_sensor_data_bitfield_t with field corresponding to index set, or 0 if</a>
<a name="ln602"> *                                   target doesn't have any data type at given index.</a>
<a name="ln603"> */</a>
<a name="ln604">rd_sensor_data_bitfield_t rd_sensor_field_type (const rd_sensor_data_t * const target,</a>
<a name="ln605">        const uint8_t index);</a>
<a name="ln606"> </a>
<a name="ln607">/** @} */</a>
<a name="ln608">#endif</a>

</code></pre>
<div class="balloon" rel="117"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2572/" target="_blank">V2572</a> The value of the '1U' expression should not be converted from the essential 'unsigned' type to the essential 'rd_bus_t' type.</p></div>
<div class="balloon" rel="118"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2572/" target="_blank">V2572</a> The value of the '2U' expression should not be converted from the essential 'unsigned' type to the essential 'rd_bus_t' type.</p></div>
<div class="balloon" rel="119"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2572/" target="_blank">V2572</a> The value of the '3U' expression should not be converted from the essential 'unsigned' type to the essential 'rd_bus_t' type.</p></div>
<div class="balloon" rel="120"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2572/" target="_blank">V2572</a> The value of the '4U' expression should not be converted from the essential 'unsigned' type to the essential 'rd_bus_t' type.</p></div>
<div class="balloon" rel="121"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2572/" target="_blank">V2572</a> The value of the '5U' expression should not be converted from the essential 'unsigned' type to the essential 'rd_bus_t' type.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
